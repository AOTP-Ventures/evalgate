# EvalGate Documentation

âš¡ **Zero Infrastructure Required**

# Stop AI Regressions Before They Ship

Automated evaluation for your AI features. Catch quality, cost, and performance issues in pull requestsâ€”before they reach production.

## The Problem

ðŸš¨ **AI Features Break in Production**

â€¢ Your LLM starts generating malformed JSON after a prompt change
â€¢ Response quality degrades but you only notice after customer complaints  
â€¢ Latency spikes from 200ms to 2s, breaking your user experience
â€¢ A model update changes behavior in subtle ways you didn't test for

**Sound familiar?** Most teams rely on manual testing or basic unit tests for AI features. But AI systems fail in ways traditional software doesn'tâ€”and those failures are expensive.

## Why EvalGate?

âœ… **Catch AI Regressions Before They Ship**

EvalGate runs comprehensive evaluations on every PR, so you know exactly how your changes affect AI quality, cost, and performanceâ€”before they reach production.

### Before/After Comparison

**Before (Without EvalGate)**
â€¢ Manual testing on a few examples
â€¢ Hope nothing breaks in production
â€¢ Debug issues after customers complain
â€¢ No visibility into cost/latency changes
â€¢ Afraid to update prompts or models

**After (With EvalGate)**
â€¢ Automated evaluation on every PR
â€¢ Catch regressions before they merge
â€¢ Clear reports on what changed
â€¢ Budget enforcement for cost/latency
â€¢ Ship AI features with confidence

## What Makes EvalGate Different?

ðŸŽ¯ **Simple Tool, Not a Platform**

EvalGate isn't another heavyweight platform to learn and manage. It's a simple, **open source** CLI tool that works exactly where you already doâ€”in GitHub PRs, with your existing workflow.

### Key Features

âš¡ **Works Where You Already Are**
No new platforms to learn. Runs in your existing GitHub PRs, posts results as comments, integrates with your current code review process. It feels native.

ðŸŽˆ **Lightweight by Design**
No servers, no databases, no dashboards to maintain. Just a CLI tool that runs when you need it. Your team can start using it in 10 minutes without any infrastructure changes.

ðŸ§  **Start Simple, Scale Sophisticated**
Begin with basic JSON validation and exact matches. Add LLM-powered evaluation when you're ready. No big upfront commitment or complex setup.

ðŸ”’ **Your Code, Your Environment**
Everything runs in your GitHub Actions. Your prompts, data, and results never leave your environment. No vendor lock-in, no external dependencies.

ðŸ”“ **Fully Open Source**
Complete transparency with MIT license. Audit every line of code, contribute improvements, or fork it for your needs. No black boxes, no hidden telemetry.
